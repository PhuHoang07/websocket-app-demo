<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>WS Chat Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
        }

        #messages {
            border: 1px solid #ccc;
            height: 300px;
            overflow-y: auto;
            padding: 10px;
            margin-top: 10px;
        }

        .msg {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .msg-content {
            white-space: pre-wrap;
        }

        .msg-status {
            font-size: 12px;
            color: gray;
            margin-left: 10px;
        }

        .system {
            color: gray;
            font-style: italic;
        }

        #connectionStatus {
            color: gray;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid #ccc;
            border-top: 2px solid #555;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <h3>WebSocket Chat Demo</h3>

    <div id="connectionStatus" style="display:none;">
        <span class="spinner"></span>
        <span>Reconnecting...</span>
    </div>

    <!-- USER -->
    <div>
        <input id="username" placeholder="Your name (for join/create)" />
    </div>

    <br />

    <!-- CREATE -->
    <button onclick="createConversation()">Create Conversation</button>

    <br /><br />

    <!-- JOIN / VIEW -->
    <input id="conversationId" placeholder="Conversation ID" />
    <button onclick="joinConversation()">Join</button>
    <button onclick="viewConversation()">View</button>

    <br /><br />

    <!-- CHAT -->
    <input id="messageInput" placeholder="Message" />
    <button onclick="sendMessage()">Send</button>

    <div id="messages"></div>

    <script>
        const messagesDiv = document.getElementById("messages");
        const messageInput = document.getElementById("messageInput");
        const pendingMessages = new Map();
        const messages = [];

        let currentConversationId = null;
        let username = null;
        let mode = null; // "JOIN" | "VIEW"
        let ws;
        let lastJoinPayload = null;

        connectWebSocket();

        function connectWebSocket() {
            const wsUrl =
                (location.protocol === "https:" ? "wss://" : "ws://") + location.host;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                hideReconnecting();
                addSystemMessage("Connected to " + wsUrl);

                if (mode === "JOIN" && lastJoinPayload) {
                    ws.send(JSON.stringify(lastJoinPayload));
                }
            };

            ws.onmessage = handleMessage;
            ws.onclose = () => {
                showReconnecting();
                setTimeout(connectWebSocket, 2000);
            };
        }

        function formatTime(dateString) {
            const date = new Date(dateString);

            return date.toLocaleString("vi-VN", {
                timeZone: "Asia/Ho_Chi_Minh",
                hour: "2-digit",
                minute: "2-digit",
                second: "2-digit",
                day: "2-digit",
                month: "2-digit",
            });
        }

        function addSystemMessage(text) {
            const div = document.createElement("div");
            div.className = "system";
            div.textContent = text;
            messagesDiv.appendChild(div);
        }

        function addChatMessage(sender, content, createdAt) {
            const div = document.createElement("div");
            div.className = "msg";

            const time = createdAt ? formatTime(createdAt) : "";
            div.textContent = `[${time}] ${sender}: ${content}`;

            messagesDiv.appendChild(div);
        }

        function setSendEnabled(enabled) {
            messageInput.disabled = !enabled;
        }

        function handleMessage(e) {
            const msg = JSON.parse(e.data);

            switch (msg.type) {
                case "CONVERSATION_CREATED":
                    currentConversationId = msg.conversationId;
                    addSystemMessage(
                        `Conversation created: ${msg.conversationId}`,
                    );
                    break;

                case "JOIN_SUCCESS":
                    mode = "JOIN";
                    currentConversationId = msg.conversationId;
                    addSystemMessage("Joined conversation");
                    setSendEnabled(true);
                    break;

                case "JOIN_REFUSED":
                    addSystemMessage("Join refused: " + msg.reason);
                    break;

                case "HISTORY":
                    const pending = getPendingMessages();

                    const historyMessages = msg.data.map((m) => ({
                        id: m.clientMessageId,
                        senderName: m.senderName,
                        content: m.content,
                        createdAt: m.createdAt,
                        status: "sent",
                    }));

                    messages.length = 0;
                    messages.push(...historyMessages, ...pending);

                    sortMessages();
                    renderMessages();
                    retryPendingMessages();

                    if (mode === "VIEW") {
                        addSystemMessage("Viewing conversation (read-only)");
                    }
                    break;

                case "NEW_MESSAGE": {
                    const idx = messages.findIndex(
                        m => m.id === msg.data.clientMessageId
                    );

                    if (idx !== -1) {
                        messages[idx].status = "sent";
                        messages[idx].createdAt = msg.data.createdAt;
                    } else {
                        messages.push({
                            id: msg.data.clientMessageId,
                            senderName: msg.data.senderName,
                            content: msg.data.content,
                            createdAt: msg.data.createdAt,
                            status: "sent",
                        });
                    }
                    renderMessages();
                    break;
                }

                case "SYSTEM":
                    addSystemMessage(msg.message);
                    autoScroll();
                    break;

                case "MESSAGE_SENT": {
                    const idx = messages.findIndex(m => m.id === msg.tempId);
                    if (idx === -1) return;

                    messages[idx].status = "sent";
                    messages[idx].createdAt = msg.data.createdAt;

                    sortMessages();
                    renderMessages();
                    break;
                }
            }
        };

        function retryPendingMessages() {
            if (ws.readyState !== WebSocket.OPEN) return;

            const pending = messages.filter(m => m.status === "sending" || m.status === "retrying");

            pending.sort((a, b) => a.clientCreatedAt - b.clientCreatedAt);

            pending.forEach((m) => {
                if (m.retryCount >= 2) {
                    m.status = "failed";
                    return;
                }
                m.status = "retrying";
                m.retryCount++;
                sendMessageToServer(m);
            });

            renderMessages();
        }

        function createConversation() {
            username = document.getElementById("username").value;
            if (!username) return alert("Enter username");

            resetState();

            ws.send(
                JSON.stringify({
                    type: "CREATE_CONVERSATION",
                    username,
                }),
            );
        }

        function joinConversation() {
            username = document.getElementById("username").value;
            const conversationId =
                document.getElementById("conversationId").value;

            if (!username || !conversationId)
                return alert("Enter username & conversationId");

            resetState();
            mode = "JOIN";

            lastJoinPayload = {
                type: "JOIN",
                username,
                conversationId,
            };

            ws.send(JSON.stringify(lastJoinPayload));
        }

        function viewConversation() {
            const conversationId =
                document.getElementById("conversationId").value;

            if (!conversationId)
                return alert("Enter conversationId");

            resetState();
            mode = "VIEW";
            currentConversationId = conversationId;

            ws.send(
                JSON.stringify({
                    type: "VIEW",
                    conversationId,
                }),
            );
        }

        function sendMessage() {
            if (mode !== "JOIN") return;

            const content = messageInput.value;
            if (!content) return;

            const tempId = crypto.randomUUID();

            messages.push({
                id: tempId,
                senderName: username,
                content,
                createdAt: null,
                clientCreatedAt: Date.now(),
                status: "sending",
                retryCount: 0,
            });

            renderMessages();
            sendMessageToServer(messages[messages.length - 1]);

            messageInput.value = "";
        }

        function sendMessageToServer(message) {
            if (ws.readyState !== WebSocket.OPEN) return false;

            ws.send(
                JSON.stringify({
                    type: "MESSAGE",
                    tempId: message.id,
                    content: message.content,
                    clientCreatedAt: message.clientCreatedAt,
                })
            );

            return true;
        }

        function sortMessages() {
            messages.sort((a, b) => {
                const timeA = a.clientCreatedAt || a.createdAt || 0;
                const timeB = b.clientCreatedAt || b.createdAt || 0;
                return timeA - timeB;
            });
        }

        function renderMessages() {
            messagesDiv.innerHTML = "";

            messages.forEach((m) => {
                const div = document.createElement("div");
                div.className = "msg";

                const text = document.createElement("span");
                let prefix = "";

                if (m.createdAt) {
                    prefix = `[${formatTime(m.createdAt)}] `;
                }

                text.textContent = `${prefix}${m.senderName}: ${m.content}`;

                div.appendChild(text);

                if (m.status !== "sent") {
                    const status = document.createElement("span");
                    status.className = "msg-status";

                    if (m.status === "sending") status.textContent = "sending...";
                    if (m.status === "retrying")
                        status.textContent = `retrying (${m.retryCount})`;
                    if (m.status === "failed")
                        status.textContent = "failed";

                    div.appendChild(status);
                }

                messagesDiv.appendChild(div);
            });

            autoScroll();
        }

        function getPendingMessages() {
            return messages.filter(
                m => m.status === "sending" ||
                    m.status === "retrying"
            );
        }

        function autoScroll() {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        function resetState() {
            mode = null;
            currentConversationId = null;
            messagesDiv.innerHTML = "";
            setSendEnabled(false);
        }

        const connectionStatusDiv = document.getElementById("connectionStatus");
        let isReconnecting = false;

        function showReconnecting() {
            if (isReconnecting) return;
            isReconnecting = true;
            connectionStatusDiv.style.display = "flex";
        }

        function hideReconnecting() {
            isReconnecting = false;
            connectionStatusDiv.style.display = "none";
        }
    </script>
</body>

</html>